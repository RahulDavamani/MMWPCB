model Service {
   id        String   @id
   createdAt DateTime @default(now())
   updatedAt DateTime @updatedAt

   userId String
   user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

   status ServiceStatus

   service             String
   company             String
   firstName           String
   lastName            String
   email               String
   phone               String
   testingRequirements String
   price               Float?
   report              String?

   paymentInfo   ServicePaymentInfo?
   notifications ServiceNotification[]
}

enum ServiceStatus {
   APPLICATION_RECEIVED
   IN_REVIEW
   WAITING_FOR_PAYMENT
   WAITING_FOR_SAMPLES
   TESTING_IN_PROGRESS
   REPORT_RELEASED
   REJECTED
}

model ServicePaymentInfo {
   id        String   @id @default(nanoid())
   createdAt DateTime @default(now())
   updatedAt DateTime @updatedAt

   paymentId String
   status    String

   captureId     String
   captureStatus String
   captureTime   DateTime

   amount   String
   currency String

   payerId    String
   payerName  String
   payerEmail String

   serviceId String  @unique
   service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
}

model ServiceNotification {
   id        String   @id @default(nanoid())
   createdAt DateTime @default(now())
   updatedAt DateTime @updatedAt

   type    String
   message String

   serviceId String
   service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)
}
